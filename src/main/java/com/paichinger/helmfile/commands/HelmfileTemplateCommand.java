package com.paichinger.helmfile.commands;import java.io.ByteArrayInputStream;import java.io.File;import java.io.InputStream;import java.util.ArrayList;import java.util.Collections;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import java.util.Optional;import java.util.stream.Collectors;import lombok.Builder;import lombok.Singular;import org.yaml.snakeyaml.Yaml;import com.fasterxml.jackson.databind.ObjectMapper;import com.paichinger.helmfile.models.template.HelmfileTemplate;import io.kubernetes.client.openapi.models.V1ClusterRole;import io.kubernetes.client.openapi.models.V1ClusterRoleBinding;import io.kubernetes.client.openapi.models.V1ConfigMap;import io.kubernetes.client.openapi.models.V1Deployment;import io.kubernetes.client.openapi.models.V1Ingress;import io.kubernetes.client.openapi.models.V1Secret;import io.kubernetes.client.openapi.models.V1Service;import io.kubernetes.client.openapi.models.V1ServiceAccount;import io.kubernetes.client.openapi.models.V1StatefulSet;@Builderpublic class HelmfileTemplateCommand {		@Builder.Default private final Configuration configuration = Configuration.builder().build() ;	@Builder.Default private final Map<String, String> stateValuesSet = Collections.emptyMap();	@Singular private final List<File> stateValuesFiles;	private final String environment;	@Singular private final List<HelmfileSelector> selectors;	private final boolean skipDeps;	private final boolean skipNeeds;	private final boolean includeTransitiveNeeds;	private final CommandUtils utils = new CommandUtils();		public HelmfileTemplate execute() {		String helmfileTemplateCommand = String.format("%s %s %s", configuration.getHelmfileBinaryPath(), "template --log-level=ERROR", String.join(" ", generateHelmfileCommandLineParameters()));		String commandLineOutput = CommandLineRunner.run(helmfileTemplateCommand, configuration.getWorkdir());		return unmarshallHelmfileTemplateOutput(commandLineOutput);	}		protected List<String> generateHelmfileCommandLineParameters() {		List<String> parameters = utils.processBasicParameters(stateValuesSet, stateValuesFiles, environment);		if (selectors != null && !selectors.isEmpty()) {			String selectorParameters = Optional					.of(selectors)					.get()					.stream()					.map(HelmfileSelector::generateParameterString)					.collect(Collectors.joining(" "));			parameters.add(selectorParameters);		}		parameters.add(skipDeps ? "--skip-deps" : "");		parameters.add(skipNeeds ? "--skip-needs" : "");		parameters.add(includeTransitiveNeeds ? "--include-transitive-needs" : "");		return parameters;	}	private HelmfileTemplate unmarshallHelmfileTemplateOutput(String yamlManifests) {		InputStream in = new ByteArrayInputStream(yamlManifests.getBytes());		Yaml yaml = new Yaml();		List<V1Service> services = new ArrayList<>();		List<V1ServiceAccount> serviceAccounts = new ArrayList<>();		List<V1ClusterRole> clusterRoles = new ArrayList<>();		List<V1ClusterRoleBinding> clusterRoleBindings = new ArrayList<>();		List<V1Secret> secrets = new ArrayList<>();		List<V1Deployment> deployments = new ArrayList<>();		List<V1ConfigMap> configMaps = new ArrayList<>();		List<V1Ingress> ingresses = new ArrayList<>();		List<V1StatefulSet> statefulSets = new ArrayList<>();		for (Object map : yaml.loadAll(in)) {			ObjectMapper mapper = new ObjectMapper();			//noinspection rawtypes			Map manifest = (LinkedHashMap) map;			if (manifest.get("kind").equals("Service")) {				services.add(mapper.convertValue(manifest, V1Service.class));			}			if (manifest.get("kind").equals("ServiceAccount")) {				serviceAccounts.add(mapper.convertValue(manifest, V1ServiceAccount.class));			}			if (manifest.get("kind").equals("ClusterRole")) {				clusterRoles.add(mapper.convertValue(manifest, V1ClusterRole.class));			}			if (manifest.get("kind").equals("ClusterRoleBinding")) {				clusterRoleBindings.add(mapper.convertValue(manifest, V1ClusterRoleBinding.class));			}			if (manifest.get("kind").equals("Deployment")) {				deployments.add(mapper.convertValue(manifest, V1Deployment.class));			}			if (manifest.get("kind").equals("Secret")) {				secrets.add(mapper.convertValue(manifest, V1Secret.class));			}			if (manifest.get("kind").equals("ConfigMap")) {				configMaps.add(mapper.convertValue(manifest, V1ConfigMap.class));			}			if (manifest.get("kind").equals("Ingress")) {				ingresses.add(mapper.convertValue(manifest, V1Ingress.class));			}			if (manifest.get("kind").equals("StatefulSet")) {				statefulSets.add(mapper.convertValue(manifest, V1StatefulSet.class));			}		}		return HelmfileTemplate.builder()				.services(services)				.serviceAccounts(serviceAccounts)				.clusterRoles(clusterRoles)				.clusterRoleBindings(clusterRoleBindings)				.secrets(secrets)				.deployments(deployments)				.configMaps(configMaps)				.ingresses(ingresses)				.statefulSets(statefulSets)				.build();	}	}